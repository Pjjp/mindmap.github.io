<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Mind Map Tool - Enhanced Version</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1e1e1e;
            color: #d4d4d4;
            font-family: sans-serif;
        }

        .node {
            cursor: pointer;
        }

        .node circle {
            fill: #3c3c3c;
            stroke: #6a9955;
            stroke-width: 1.5px;
        }

        .node text {
            font: 12px sans-serif;
            pointer-events: none;
            fill: #d4d4d4;
            text-anchor: start;
        }

        .link {
            fill: none;
            stroke: #555;
            stroke-width: 1.5px;
        }

        /* Highlight connected links */
        .link.highlighted {
            stroke: #d16969;
            stroke-width: 3px;
        }

        /* Selected link style */
        .link.selected {
            stroke: #d16969;
            stroke-width: 3px;
        }

        /* Blurred nodes and links */
        .node.blurred {
            opacity: 0.2;
        }

        .link.blurred {
            opacity: 0.2;
        }

        /* Hovered node style */
        .node.hovered circle {
            stroke: #d16969;
            stroke-width: 3px;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 10;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(30, 30, 30, 0.95);
        }

        .modal-content {
            background-color: #252526;
            margin: 0;
            padding: 20px;
            border: none;
            width: 100%;
            height: 100%;
            box-sizing: border-box;
            color: #d4d4d4;
            overflow: hidden;
            position: relative;
        }

        #save-button, #close-button, #delete-node-button, #save-mindmap-button, #load-mindmap-button, #instructions-button {
            background-color: #0e639c;
            color: #ffffff;
            border: none;
            padding: 10px 20px;
            margin: 10px 5px 0 0;
            cursor: pointer;
            font-size: 14px;
        }

        #delete-node-button {
            background-color: #d16969;
        }

        #save-button:hover, #close-button:hover, #delete-node-button:hover, #save-mindmap-button:hover, #load-mindmap-button:hover, #instructions-button:hover {
            background-color: #1177bb;
        }

        #delete-node-button:hover {
            background-color: #e18080;
        }

        /* Positioning Save and Close buttons in the modal */
        #modal-buttons {
            position: absolute;
            top: 10px;
            right: 10px;
        }

        /* Toolbar button colors */
        .editor-toolbar a {
            color: #d4d4d4 !important;
        }

        .editor-toolbar {
            background-color: #333;
            border-bottom: 1px solid #444;
        }

        .editor-toolbar a:hover {
            color: #fff !important;
        }

        .editor-statusbar {
            background-color: #333;
            border-top: 1px solid #444;
            color: #ccc;
        }

        /* Editor styles */
        .CodeMirror {
            background-color: #1e1e1e !important;
            color: #d4d4d4;
        }

        .CodeMirror-gutters {
            background-color: #1e1e1e !important;
            border-right: 0;
        }

        /* Changed cursor color to white */
        .CodeMirror-cursor {
            border-left: 1px solid #ffffff;
        }

        .CodeMirror-lines {
            color: #d4d4d4;
        }

        .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {
            background-color: #1e1e1e !important;
        }

        /* Markdown Editor Styles */
        #toolbar {
            padding: 10px;
            background-color: #444;
            display: flex;
            gap: 5px;
        }

        #toolbar button {
            background-color: #555;
            border: none;
            color: white;
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 3px;
        }

        #toolbar button:hover {
            background-color: #666;
        }

        #container {
            display: flex;
            flex-direction: row;
            flex: 1;
            overflow: hidden;
            height: calc(100% - 60px);
        }

        #editor {
            padding: 10px;
            overflow-y: auto;
            box-sizing: border-box;
            width: 100%;
            background-color: #333;
            color: #ffffff;
            flex: 1;
        }

        #editorContent {
            width: 100%;
            height: 100%;
            border: none;
            outline: none;
            font-size: 16px;
            font-family: inherit;
            padding: 5px;
            overflow-y: auto;
            color: #ffffff;
        }

        /* Styles for the image size slider */
        #imageSizeControls {
            display: none; /* Ensure it is displayed */
            flex-direction: column;
            padding: 10px 0;
            align-items: center;
            position: absolute; /* Make it positioned relative to its container */
            z-index: 1000; /* Ensure it's on top */
            background-color: rgba(30, 30, 30, 0.9); /* Optional: Add a background to differentiate it */
            top: 10px; /* Adjust as needed to ensure proper placement */
            left: 10px; /* Adjust as needed to ensure proper placement */
            border: 1px solid #555; /* Optional: Add a border for visibility */
            padding: 10px;
        }

        #sizeSlider {
            width: 80%;
        }

        #sizeValue {
            margin-top: 5px;
        }

        /* Style for selected image */
        .selected {
            outline: 2px solid #007BFF;
        }

        /* Label input style */
        #labelInput {
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            background-color: #3c3c3c;
            color: #d4d4d4;
            border: 1px solid #555;
            font-size: 16px;
            resize: vertical;
            min-height: 60px;
        }

        /* Instructions Panel */
        #instructionsPanel {
            display: none;
            color: #d4d4d4;
            margin-top: 10px;
        }

        #instructionsPanel ul {
            padding-left: 20px;
        }
    </style>
    <!-- SimpleMDE CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/simplemde@1.11.2/dist/simplemde.min.css">
    <!-- FontAwesome for toolbar icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
</head>
<body>
    <!-- Control Buttons -->
    <div style="position: absolute; top: 10px; left: 10px; z-index: 5;">
        <button id="save-mindmap-button">Save Mind Map</button>
        <button id="load-mindmap-button">Load Mind Map</button>
        <button id="instructions-button">Instructions</button>
        <div id="instructionsPanel">
            <p>Instructions:</p>
            <ul>
                <li>Hover over a node to highlight it and its connections.</li>
                <li>Hold <strong>Ctrl</strong> and click another node to create a link.</li>
                <li>Double-click a node to edit content and label.</li>
                <li>Click a link to select it, then press <strong>Delete</strong> to remove it.</li>
            </ul>
        </div>
    </div>

    <!-- Modal for editing markdown and label -->
    <div id="modal" class="modal">
        <div class="modal-content">
            <!-- Positioning Save and Close buttons -->
            <div id="modal-buttons">
                <button id="save-button">Save</button>
                <button id="close-button">Close</button>
                <button id="delete-node-button">Delete Node</button>
            </div>
            <h2>Edit Node</h2>
            <textarea id="labelInput" placeholder="Node Label"></textarea>
            <div id="toolbar">
                <button id="insertImage">Insert Image</button>
                <button onclick="formatText('bold')">Bold</button>
                <button onclick="formatText('italic')">Italic</button>
                <button onclick="formatText('h1')">H1</button>
                <button onclick="formatText('h2')">H2</button>
                <button onclick="formatText('ul')">Bullet List</button>
                <button onclick="formatText('ol')">Numbered List</button>
                <input type="file" id="imageInput" accept="image/*" style="display:none">
            </div>
            <div id="container">
                <div id="editor">
                    <div id="editorContent" contenteditable="true"></div>
                    <div id="imageSizeControls">
                        <input type="range" id="sizeSlider" min="10" max="1000" value="300">
                        <div id="sizeValue">Width: 300px</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- D3.js library -->
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <!-- SimpleMDE JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/simplemde@1.11.2/dist/simplemde.min.js"></script>
    <!-- FileSaver.js for saving files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <!-- JSZip for creating ZIP files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
    <!-- JSZip-utils for loading ZIP files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip-utils/0.1.0/jszip-utils.min.js"></script>
    <!-- CodeMirror Theme JavaScript -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/theme/dracula.min.js"></script>

    <script>
        const width = window.innerWidth;
        const height = window.innerHeight;

        // Create the SVG canvas
        const svg = d3.select("body")
            .append("svg")
            .attr("width", width)
            .attr("height", height)
            .style("background-color", "#1e1e1e");

        // Add a group element to SVG
        const g = svg.append("g");

        // Enable zoom and pan
        svg.call(d3.zoom()
            .scaleExtent([0.5, 8])
            .on("zoom", (event) => {
                g.attr("transform", event.transform);
            }));

        // Initialize nodes and links data
        let nodes = [];
        let links = [];

        // Initialize the force simulation
        const simulation = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(links).distance(180).id(d => d.id))
            .force("charge", d3.forceManyBody().strength(-20))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("collide", d3.forceCollide().radius(d => d.radius + 5).iterations(2));

        let link = g.append("g")
            .attr("class", "links")
            .selectAll(".link");

        let node = g.append("g")
            .attr("class", "nodes")
            .selectAll(".node");

        let selectedNode = null;
        let selectedLink = null;
        let selectedLinkData = null;

        // Add node on canvas click
        svg.on("click", function (event) {
            if (event.defaultPrevented) return; // dragged

            // Deselect any selected link
            if (selectedLink) {
                selectedLink.classed('selected', false);
                selectedLink = null;
                selectedLinkData = null;
            } else {
                const point = d3.pointer(event, svg.node());
                const nodeData = { id: Date.now(), x: point[0], y: point[1], content: "", label: "Node" };
                nodes.push(nodeData);

                restart();
            }
        });

        // Function to calculate node degrees and set radii
        function calculateNodeDegrees() {
            let minDegree = Infinity;
            let maxDegree = -Infinity;

            nodes.forEach(function (node) {
                node.degree = links.reduce(function (count, link) {
                    if (link.source === node || link.target === node) {
                        return count + 1;
                    }
                    return count;
                }, 0);

                if (node.degree < minDegree) minDegree = node.degree;
                if (node.degree > maxDegree) maxDegree = node.degree;
            });

            // Now set the radius based on degree, using logarithmic scaling
            const minRadius = 15;
            const maxRadius = 20; // Slightly bigger than minRadius

            nodes.forEach(function (node) {
                if (minDegree === maxDegree) {
                    // All nodes have the same degree
                    node.radius = (minRadius + maxRadius) / 2;
                } else {
                    // Logarithmic scaling
                    const degreeLog = Math.log(node.degree + 1);
                    const minDegreeLog = Math.log(minDegree + 1);
                    const maxDegreeLog = Math.log(maxDegree + 1);
                    node.radius = minRadius + (degreeLog - minDegreeLog) * (maxRadius - minRadius) / (maxDegreeLog - minDegreeLog);
                }
            });
        }

        // Update and restart the simulation
        function restart() {
            // Calculate node degrees and radii
            calculateNodeDegrees();

            // Update nodes
            node = node.data(nodes, d => d.id);

            node.exit().remove();

            const nodeEnter = node.enter().append("g")
                .attr("class", "node")
                .on("click", function (event, d) {
                    event.stopPropagation(); // prevent svg click

                    if (event.ctrlKey && selectedNode && selectedNode !== d) {
                        // Create a link between selectedNode and d
                        links.push({ source: selectedNode, target: d });
                        selectedNode = null;
                        restart();
                    } else if (event.ctrlKey) {
                        selectedNode = d;
                    } else {
                        openContentModal(d);
                    }
                })
                .on("dblclick", function(event, d) {
                    openContentModal(d);
                })
                .on("mouseover", function (event, d) {
                    hoverNode(d);
                })
                .on("mouseout", function (event, d) {
                    unhoverNode();
                })
                .call(drag(simulation));

            nodeEnter.append("circle")
                .attr("r", d => d.radius)
                .attr("fill", d => d.content ? "#6a9955" : "#3c3c3c");

            nodeEnter.append("text")
                .attr("dy", function(d) {
                    const lines = (d.label || "Node").split('\n');
                    return -(lines.length - 1) * 7;
                })
                .attr("x", d => d.radius + 5)
                .selectAll("tspan")
                .data(function(d) {
                    return (d.label || "Node").split('\n');
                })
                .enter()
                .append("tspan")
                .attr("x", 0)
                .attr("dy", "1.2em")
                .text(function(line) { return line; });

            node = nodeEnter.merge(node);

            // Update node circles with new radii
            node.select("circle")
                .attr("r", d => d.radius);

            // Update node labels position and content
            node.select("text")
                .attr("dy", function(d) {
                    const lines = (d.label || "Node").split('\n');
                    return -(lines.length - 1) * 7;
                })
                .selectAll("tspan")
                .data(function(d) {
                    return (d.label || "Node").split('\n');
                })
                .join(
                    enter => enter.append("tspan")
                        .attr("x", 0)
                        .attr("dy", "1.2em")
                        .text(function(line) { return line; }),
                    update => update.text(function(line) { return line; }),
                    exit => exit.remove()
                );

            // Update links
            link = link.data(links, d => d.source.id + "-" + d.target.id);

            link.exit().remove();

            link = link.enter().append("line")
                .attr("class", "link")
                .on("click", function(event, d) {
                    event.stopPropagation();
                    selectLink(d3.select(this), d);
                })
                .merge(link);

            // Restart simulation
            simulation.nodes(nodes);
            simulation.force("link").links(links);
            simulation.alpha(1).restart();
        }

        // Update positions on each simulation tick
        simulation.on("tick", () => {
            link
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);

            node
                .attr("transform", d => `translate(${d.x},${d.y})`);
        });

        // Drag behavior
        function drag(simulation) {
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }

            return d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended);
        }

        // Hover behavior
        function hoverNode(d) {
            node.classed('blurred', n => !isConnected(d, n));
            link.classed('blurred', l => l.source !== d && l.target !== d);
            node.classed('hovered', n => n === d);
            link.classed('highlighted', l => l.source === d || l.target === d);
        }

        function unhoverNode() {
            node.classed('blurred', false);
            link.classed('blurred', false);
            node.classed('hovered', false);
            link.classed('highlighted', false);
        }

        function isConnected(a, b) {
            return links.some(l => (l.source === a && l.target === b) || (l.source === b && l.target === a)) || a === b;
        }

        // Handle link selection
        function selectLink(linkElement, linkData) {
            // Deselect any previously selected link
            if (selectedLink) {
                selectedLink.classed('selected', false);
            }
            if (selectedLink === linkElement) {
                // If the link is already selected, deselect it
                selectedLink = null;
                selectedLinkData = null;
            } else {
                // Select the new link
                selectedLink = linkElement;
                selectedLinkData = linkData;
                selectedLink.classed('selected', true);
            }
        }

        // Handle keydown events for deleting links
        window.addEventListener('keydown', function(event) {
            if (event.key === 'Delete' || event.key === 'Backspace') {
                if (selectedLinkData) {
                    if (confirm("Are you sure you want to delete this link?")) {
                        // Remove the link
                        links = links.filter(l => l !== selectedLinkData);
                        selectedLink.remove();
                        selectedLink = null;
                        selectedLinkData = null;
                        restart();
                    }
                }
            }
        });

        // Modal handling for content and label
        const modal = document.getElementById("modal");
        const saveButton = document.getElementById("save-button");
        const closeButton = document.getElementById("close-button");
        const deleteNodeButton = document.getElementById("delete-node-button");
        const labelInput = document.getElementById("labelInput");
        let currentNode = null;

        function openContentModal(d) {
            currentNode = d;
            modal.style.display = "block";

            editorContent.innerHTML = d.content || "";
            labelInput.value = d.label || "Node";
        }

        saveButton.onclick = function () {
            if (currentNode) {
                currentNode.content = editorContent.innerHTML;
                currentNode.label = labelInput.value;
                // Update node appearance to indicate content
                restart();
            }
            closeContentModal();
        };

        closeButton.onclick = closeContentModal;

        deleteNodeButton.onclick = function () {
            if (currentNode) {
                if (confirm("Are you sure you want to delete this node?")) {
                    // Delete the node
                    nodes = nodes.filter(n => n !== currentNode);
                    // Remove links connected to the node
                    links = links.filter(l => l.source !== currentNode && l.target !== currentNode);
                    currentNode = null;
                    restart();
                    closeContentModal();
                }
            }
        };

        function closeContentModal() {
            modal.style.display = "none";
            currentNode = null;
        }

        // Close modals when clicking outside of them
        window.onclick = function (event) {
            if (event.target == modal) {
                closeContentModal();
            }
        };

        // Save and Load Mind Map
        const saveMindMapButton = document.getElementById("save-mindmap-button");
        const loadMindMapButton = document.getElementById("load-mindmap-button");

        saveMindMapButton.onclick = async function() {
            const mindMapData = {
                nodes: nodes.map(d => ({
                    id: d.id,
                    x: d.x,
                    y: d.y,
                    contentFile: d.content ? `node_${d.id}.html` : null, // Changed to .html to preserve data-image-id
                    label: d.label
                })),
                links: links.map(d => ({
                    source: d.source.id,
                    target: d.target.id
                }))
            };

            const zip = new JSZip();
            zip.file("mindmap.json", JSON.stringify(mindMapData, null, 2));

            // Add markdown files and images
            for (const d of nodes) {
                if (d.content) {
                    // Extract and save images within the content
                    const div = document.createElement('div');
                    div.innerHTML = d.content;
                    const images = div.querySelectorAll('img');
                    images.forEach((img, index) => {
                        const imageData = img.src.split(',')[1]; // base64 data
                        const imageName = `node_${d.id}_img_${index}.png`;
                        zip.file(imageName, imageData, { base64: true });
                        // Replace src with relative path in content
                        img.setAttribute('src', imageName);
                        // Preserve data-image-id
                        const imageId = img.getAttribute('data-image-id');
                        if (imageId) {
                            // Optionally, you can store the imageId in a separate metadata file if needed
                        }
                    });

                    // Save modified content as HTML to preserve data-image-id
                    zip.file(`node_${d.id}.html`, div.innerHTML);
                }
            }

            const content = await zip.generateAsync({ type: "blob" });

            // Use File System Access API if available
            if (window.showSaveFilePicker) {
                try {
                    const options = {
                        suggestedName: 'mindmap.zip',
                        types: [{
                            description: 'ZIP Files',
                            accept: {'application/zip': ['.zip']},
                        }],
                    };
                    const handle = await window.showSaveFilePicker(options);
                    const writable = await handle.createWritable();
                    await writable.write(content);
                    await writable.close();
                    alert('Mind map saved successfully.');
                } catch (err) {
                    console.error(err);
                    // Fallback to FileSaver.js
                    saveAs(content, 'mindmap.zip');
                    alert('Mind map saved successfully.');
                }
            } else {
                // Fallback to FileSaver.js
                saveAs(content, 'mindmap.zip');
                alert('Mind map saved successfully.');
            }
        };

        loadMindMapButton.onclick = async function () {
            if (window.showOpenFilePicker) {
                try {
                    const [fileHandle] = await window.showOpenFilePicker({
                        types: [{
                            description: 'ZIP Files',
                            accept: {'application/zip': ['.zip']},
                        }],
                    });
                    const file = await fileHandle.getFile();
                    loadMindMapFile(file);
                } catch (err) {
                    console.error(err);
                }
            } else {
                // Fallback for browsers without File System Access API
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.zip';
                input.onchange = (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        loadMindMapFile(file);
                    }
                };
                input.click();
            }
        };

        async function loadMindMapFile(file) {
            JSZip.loadAsync(file).then(function (zip) {
                return zip.file("mindmap.json").async("string").then(function (data) {
                    const mindMapData = JSON.parse(data);
                    const nodePromises = mindMapData.nodes.map(d => {
                        if (d.contentFile) {
                            return zip.file(d.contentFile).async("string").then(function (content) {
                                // Create a container for the content
                                const div = document.createElement('div');

                                // Load images back into the content
                                const tempDiv = document.createElement('div');
                                tempDiv.innerHTML = content;
                                const images = tempDiv.querySelectorAll('img');
                                const imagePromises = Array.from(images).map(img => {
                                    const imageName = img.getAttribute('src');
                                    return zip.file(imageName).async("base64").then(data => {
                                        img.src = 'data:image/png;base64,' + data;
                                        // Reassign data-image-id based on image name
                                        // Assuming imageName is in the format 'node_ID_img_index.png'
                                        const imageId = imageName.replace('.png', '');
                                        img.setAttribute('data-image-id', imageId);
                                        // Populate imageDataMap
                                        imageDataMap[imageId] = {
                                            dataUrl: img.src,
                                            width: img.width,
                                            height: img.height,
                                            aspectRatio: img.width / img.height
                                        };
                                    });
                                });

                                return Promise.all(imagePromises).then(() => {
                                    div.innerHTML = tempDiv.innerHTML;
                                    return { ...d, content: div.innerHTML };
                                });
                            });
                        } else {
                            return Promise.resolve({ ...d, content: "" });
                        }
                    });

                    Promise.all(nodePromises).then(function (loadedNodes) {
                        nodes = loadedNodes;
                        links = mindMapData.links.map(d => ({
                            source: nodes.find(n => n.id === d.source),
                            target: nodes.find(n => n.id === d.target)
                        }));
                        restart();
                    });
                });
            });
        }

        // Markdown editor
        const editorContent = document.getElementById('editorContent');
        const insertImageButton = document.getElementById('insertImage');
        const imageInput = document.getElementById('imageInput');
        const imageSizeControls = document.getElementById('imageSizeControls');
        const sizeSlider = document.getElementById('sizeSlider');
        const sizeValue = document.getElementById('sizeValue');

        let imageCounter = 0;
        const imageDataMap = {}; // Map to store image data with IDs
        let selectedImage = null;

        // Handle image insertion
        insertImageButton.addEventListener('click', () => {
            imageInput.click();
        });

        imageInput.addEventListener('change', () => {
            const file = imageInput.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const dataUrl = event.target.result;
                    const img = new Image();
                    img.onload = function() {
                        const naturalWidth = img.naturalWidth;
                        const naturalHeight = img.naturalHeight;
                        const aspectRatio = naturalWidth / naturalHeight;

                        // Assign a unique ID to the image
                        imageCounter += 1;
                        const imageId = 'image' + imageCounter;

                        // Assign data-image-id
                        // It's important to have a unique identifier for each image
                        // You can also use more robust unique ID generators if needed
                        const imageElement = new Image();
                        imageElement.src = dataUrl;
                        imageElement.setAttribute('data-image-id', imageId);
                        imageElement.alt = 'Alt Text';
                        imageElement.width = 300; // Default width
                        imageElement.height = Math.round(300 / aspectRatio); // Maintain aspect ratio

                        // Store the image data and dimensions
                        imageDataMap[imageId] = {
                            dataUrl: dataUrl,
                            width: 300,
                            height: Math.round(300 / aspectRatio),
                            aspectRatio: aspectRatio
                        };

                        // Insert image at cursor position
                        insertImageAtCursor(imageElement);
                    };
                    img.src = dataUrl;
                };
                reader.readAsDataURL(file);
            }
        });

        // Insert image at cursor position
        function insertImageAtCursor(imageElement) {
            const sel = window.getSelection();
            if (sel.rangeCount > 0) {
                const range = sel.getRangeAt(0);
                range.deleteContents();
                range.insertNode(imageElement);
                // Move cursor after the image
                range.setStartAfter(imageElement);
                range.setEndAfter(imageElement);
                sel.removeAllRanges();
                sel.addRange(range);
            } else {
                editorContent.appendChild(imageElement);
            }
        }

        // Handle image selection
        editorContent.addEventListener('click', (event) => {
            if (event.target.tagName === 'IMG') {
                selectImage(event.target);
            } else {
                deselectImage();
            }
        });

        function selectImage(imgElement) {
            deselectImage();
            selectedImage = imgElement;
            imgElement.classList.add('selected');

            // Get image info
            const imageId = imgElement.getAttribute('data-image-id');
            const imageInfo = imageDataMap[imageId];

            if (imageInfo) {
                // Set slider value and display controls
                sizeSlider.value = imageInfo.width;
                sizeSlider.max = imageInfo.width * 4; // Allow scaling up to 4 times
                sizeValue.innerText = `Width: ${imageInfo.width}px`;

                imageSizeControls.style.display = 'flex';
            } else {
                // If imageInfo is not found, hide the slider
                imageSizeControls.style.display = 'none';
            }
        }

        function deselectImage() {
            if (selectedImage) {
                selectedImage.classList.remove('selected');
                selectedImage = null;
                imageSizeControls.style.display = 'none';
            }
        }

        // Handle size slider adjustment
        sizeSlider.addEventListener('input', () => {
            if (selectedImage) {
                const imageId = selectedImage.getAttribute('data-image-id');
                const imageInfo = imageDataMap[imageId];

                if (imageInfo) {
                    const newWidth = parseInt(sizeSlider.value);
                    const newHeight = Math.round(newWidth / imageInfo.aspectRatio);

                    // Update image element
                    selectedImage.width = newWidth;
                    selectedImage.height = newHeight;

                    // Update image data
                    imageInfo.width = newWidth;
                    imageInfo.height = newHeight;

                    sizeValue.innerText = `Width: ${newWidth}px`;
                }
            }
        });

        // Function to format text
        function formatText(command) {
            switch (command) {
                case 'bold':
                    document.execCommand('bold');
                    break;
                case 'italic':
                    document.execCommand('italic');
                    break;
                case 'h1':
                    document.execCommand('formatBlock', false, 'h1');
                    break;
                case 'h2':
                    document.execCommand('formatBlock', false, 'h2');
                    break;
                case 'ul':
                    document.execCommand('insertUnorderedList');
                    break;
                case 'ol':
                    document.execCommand('insertOrderedList');
                    break;
            }
        }

        // Toggle Instructions
        const instructionsButton = document.getElementById('instructions-button');
        const instructionsPanel = document.getElementById('instructionsPanel');

        instructionsButton.onclick = function() {
            if (instructionsPanel.style.display === 'none' || instructionsPanel.style.display === '') {
                instructionsPanel.style.display = 'block';
            } else {
                instructionsPanel.style.display = 'none';
            }
        };
    </script>
</body>
</html>
